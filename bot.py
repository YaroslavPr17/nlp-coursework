import copy
import os
from pathlib import Path
from typing import Dict

import numpy as np
import telebot
import torch.cuda
from telebot import types
from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton
from transformers import pipeline

from datasets_ import DatasetLoader

from src.nlp.classification import Pipeline
from src.nlp.application import get_df_by_person, get_df_by_film_and_person
from src.nlp.info_extraction import get_person_characteristics

bot = telebot.TeleBot('6151372769:AAFFdINtx93_dgK2LVg5FDzq5ZyHyI5GH14', parse_mode='MARKDOWN')
image_path = Path('data', 'images')
if not os.path.exists(image_path):
    os.makedirs(image_path)
ne_dataset = DatasetLoader.load_named_entities_dataset()

qa_model_name = "AlexKay/xlm-roberta-large-qa-multilingual-finedtuned-ru"
device = 'cuda:0' if torch.cuda.is_available() else 'cpu'
qa_model = pipeline('question-answering', model=qa_model_name, tokenizer=qa_model_name, device=device)

SENTIMENT_TEXT = '–•–æ—á—É —É–∑–Ω–∞—Ç—å —Ç–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å –æ—Ç–∑—ã–≤–∞!'
PERSON_TEXT = '–ö–∞–∫–æ–≤ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —á–µ–ª–æ–≤–µ–∫?'
ASK_REVIEW = '–ù–∞–ø–∏—à–∏—Ç–µ –æ—Ç–∑—ã–≤ –æ —á—ë–º-–ª–∏–±–æ'
ASK_NAME = "–í–≤–µ–¥–∏—Ç–µ –∏–º—è —á–µ–ª–æ–≤–µ–∫–∞ –∏ id —Ñ–∏–ª—å–º–∞ (–ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏), —Ä–∞–∑–¥–µ–ª—ë–Ω–Ω—ã–µ –∑–Ω–∞–∫–æ–º –¥–µ—Ñ–∏—Å ('-')"


class User:
    def __init__(self, chat_id):
        self.chat_id = chat_id
        self.task = None
        self.request_name = None
        self.request_film_id = None


users: Dict[int, User] = {}

@bot.message_handler(commands=['start'])
def start_message(message):
    bot.send_message(message.chat.id, "–ü—Ä–∏–≤–µ—Ç ‚úåÔ∏è\n"
                                      "–í—ã –º–æ–∂–µ—Ç–µ –∫–ª–∞—Å—Å–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å —Å–≤–æ–π –æ—Ç–∑—ã–≤ –∏ –Ω–∞–π—Ç–∏ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫—É –∞–∫—Ç—ë—Ä–∞ –∏–ª–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞.")
    keyboard = types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
    keyboard.add(types.KeyboardButton(SENTIMENT_TEXT))
    keyboard.add(types.KeyboardButton(PERSON_TEXT))
    users[message.chat.id] = User(chat_id=message.chat.id)
    bot.send_message(message.chat.id, '–ß—Ç–æ –í—ã —Ö–æ—Ç–∏—Ç–µ —Å–¥–µ–ª–∞—Ç—å?', reply_markup=keyboard)


@bot.message_handler(func=lambda message: message.text == SENTIMENT_TEXT and message.content_type == 'text')
def sentiment_message_handler(message):
    @bot.message_handler(func=lambda message: message.content_type == 'text')
    def review_handler(message):
        if len(message.text.split()) < 10:
            bot.send_message(message.chat.id, '–†–µ—Ü–µ–Ω–∑–∏—è —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∞')
            return
        pred, ret_value = Pipeline('classification', preprocess=False)([message.text], return_confs=True,
                                                                       visualize=True)
        id2label = {0: 'üòû–ù–µ–≥–∞—Ç–∏–≤–Ω—ã–πüòû', 1: 'üòÑ–ü–æ–∑–∏—Ç–∏–≤–Ω—ã–πüòÑ', 2: 'üòÑ–ü–æ–∑–∏—Ç–∏–≤–Ω—ã–πüòÑ'}
        bot.send_message(message.chat.id, ret_value['new_doc'])
        with open(ret_value['graph_path'], 'rb') as graph_file:
            bot.send_photo(message.chat.id, graph_file.read(), caption=id2label[pred[0]])
        os.remove(ret_value['graph_path'])

    if message.chat.id not in users:
        users[message.chat.id] = User(message.chat.id)
    users[message.chat.id].task = 'classification'

    msg = bot.send_message(message.chat.id, ASK_REVIEW)
    bot.register_next_step_handler(msg, review_handler)


@bot.message_handler(func=lambda message: message.text == PERSON_TEXT and message.content_type == 'text')
def person_message_handler(message):
    @bot.message_handler(func=lambda name_id_message: name_id_message.content_type == 'text')
    def name_message_handler(name_id_message):
        ANSWERS_THRESHOLD = 0.18

        name, film_id = None, None
        if '-' in name_id_message.text:
            name, film_id = name_id_message.text.split('-')
            name, film_id = name.strip(), film_id.strip()
            bot.send_message(name_id_message.chat.id, f"–ó–∞–ø—Ä–æ—Å: {name}, id: {film_id}")
        else:
            name = name_id_message.text.strip()
            bot.send_message(name_id_message.chat.id, f"–ó–∞–ø—Ä–æ—Å: {name}")

        if name is None or not name:
            bot.send_message(name_id_message.chat.id, '–ù–µ –≤–≤–µ–¥–µ–Ω–æ –∏–º—è –ø–µ—Ä—Å–æ–Ω—ã. –û—Ç–º–µ–Ω–∞ –ø–æ–∏—Å–∫–∞.')
            return

        if not film_id:
            film_id = None
        else:
            users[name_id_message.chat.id].request_film_id = int(film_id)

        users[name_id_message.chat.id].request_name = name

        try:
            if film_id is not None:
                film_id = int(film_id)
        except ValueError:
            bot.send_message(name_id_message.chat.id, '–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π id —Ñ–∏–ª—å–º–∞')
            return

        scores, answers = get_person_characteristics(ne_dataset, users[name_id_message.chat.id].request_name, qa_model,
                                                     users[name_id_message.chat.id].request_film_id, n_qa_sessions=5)

        if not len(scores):
            bot.send_message(name_id_message.chat.id, '–ù–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –ø—Ä–æ —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ —á–µ–ª–æ–≤–µ–∫–∞ :(')
            return

        clean_answers = np.array(list(map(lambda s: s.strip(' .,:'), answers)))
        best_clean_answers = clean_answers[scores > ANSWERS_THRESHOLD]
        out_str = ''
        for answer in best_clean_answers:
            out_str += f'{telebot.formatting.mbold(str(answer.capitalize()))}\n\n'
        bot.send_message(name_id_message.chat.id, out_str)

    if message.chat.id not in users:
        users[message.chat.id] = User(message.chat.id)
    users[message.chat.id].task = 'person_info'

    msg = bot.send_message(message.chat.id, ASK_NAME)
    bot.register_next_step_handler(msg, name_message_handler)




@bot.message_handler(commands=['help'])
def help_message(message):
    bot.send_message(message.chat.id, "–Ø –±–æ—Ç-–∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –æ—Ç–∑—ã–≤–æ–≤ –Ω–∞ —Ñ–∏–ª—å–º—ã!\n"
                                      "–ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤ –º–µ–Ω—é –∏ –≤—ã–±–µ—Ä–∏—Ç–µ –Ω—É–∂–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ!'")






@bot.message_handler(commands=['search_film'])
def search_film_pipeline_message(message):
    @bot.message_handler(content_types=['text'])
    def get_film_title(inner_message):
        film_title = inner_message.text
        # print(dataset[dataset["title"].str.contains(film_title)])
        films_accepted = dataset[dataset["title"].str.contains(film_title, case=False)]
        bot.send_message(message.chat.id,
                         str(films_accepted))

    msg = bot.send_message(message.chat.id, "–í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ, –≤—Å—Ç—Ä–µ—á–∞—é—â–µ–µ—Å—è –≤ —Ñ–∏–ª—å–º–µ")
    bot.register_next_step_handler(msg, get_film_title)


@bot.message_handler(content_types=['text'])  # ['text', 'document', 'audio']
def get_text_messages(message):
    if message.text.lower() == "–ø—Ä–∏–≤–µ—Ç":
        bot.send_message(message.from_user.id, "–ü—Ä–∏–≤–µ—Ç, —á–µ–º —è –º–æ–≥—É —Ç–µ–±–µ –ø–æ–º–æ—á—å?")
    elif message.text == '–ü–æ–∫–∞–∂–∏ –≤—Å–µ —Ñ–∏–ª—å–º—ã':
        films = DatasetLoader.load_films_Id_Title_Year_dataset()
        bot.send_message(message.from_user.id, str(films['title'].values[:10]))
    else:
        bot.send_message(message.from_user.id, "–Ø —Ç–µ–±—è –Ω–µ –ø–æ–Ω–∏–º–∞—é. –ù–∞–ø–∏—à–∏ /help.")


if __name__ == "__main__":
    print('Bot started!')
    bot.polling(none_stop=True, interval=0)
